# Day 8: CPU 五级流水线详解 | Detailed Explanation of 5-Stage CPU Pipeline

## 🎯 学习目标 | Learning Goals

- 理解 CPU 五级流水线的每个阶段（IF, ID, EX, MEM, WB）
- 掌握流水线带来的性能提升（指令周期、吞吐量）
- 能够手绘流水线图表示指令并行执行过程（甘特图）

---

## 🧠 什么是流水线？

在计算机中，流水线（Pipeline）是一种将指令执行过程拆分成多个阶段，并行处理多个指令的技术。类似工厂流水线，每个工序同时处理不同产品的不同步骤，从而提升整体效率。

### 5 个基本阶段（5-stage Pipeline）

| 阶段 | 名称             | 功能说明 |
|------|------------------|----------|
| IF   | Instruction Fetch | 从内存中取指令 |
| ID   | Instruction Decode | 解码指令，读取寄存器 |
| EX   | Execute           | 执行操作，例如算术/逻辑运算 |
| MEM  | Memory Access     | 访问内存（如果需要） |
| WB   | Write Back        | 将结果写回寄存器 |

---

## 🏗️ 每阶段详解

### IF：Instruction Fetch

- 通过 PC（程序计数器）获取下一条指令的地址
- 从指令内存中读取指令
- PC += 4（假设每条指令为 4 字节）

### ID：Instruction Decode

- 解析操作码，识别需要的操作
- 读取源操作数（从寄存器堆）
- 准备控制信号供下一阶段使用

### EX：Execute

- 进行 ALU 运算（如加法、减法、比较等）
- 计算地址（若是 load/store 指令）
- 判断跳转条件是否成立（分支指令）

### MEM：Memory Access

- 若为 load 指令：读取内存数据
- 若为 store 指令：写入数据到内存
- 其他指令可跳过该阶段

### WB：Write Back

- 将 EX 或 MEM 阶段的结果写入目标寄存器
- 保证程序状态更新

---

## 📈 手绘示意：5 指令流水线甘特图

假设以下 5 条指令顺序执行（没有数据冲突）：

1. `add x1, x2, x3`
2. `sub x4, x5, x6`
3. `and x7, x8, x9`
4. `or  x10, x11, x12`
5. `lw  x13, 0(x14)`

```
周期数 →     1   2   3   4   5   6   7   8   9
-----------------------------------------------
指令1         IF  ID  EX  MEM WB
指令2             IF  ID  EX  MEM WB
指令3                 IF  ID  EX  MEM WB
指令4                     IF  ID  EX  MEM WB
指令5                         IF  ID  EX  MEM WB
```

📌 说明：
- 每条指令只延迟一个周期进入流水线
- 理想状态下，每周期可以完成一条指令的写回操作
- 实际中会存在冒险（Hazard）问题，需加入冒险检测与数据转发机制

---

## 🚧 注意：流水线中的冒险

- **数据冒险**：后续指令依赖前一条尚未写回的结果
- **结构冒险**：多个指令竞争同一个硬件资源
- **控制冒险**：分支指令跳转导致指令流不确定

解决方案包括：
- 插入 NOP（空操作）
- 数据前递（Forwarding）
- 分支预测（Branch Prediction）

---

## ✅ 今日任务

1. 理解每个阶段的功能及数据流走向
2. 手绘或使用表格工具画出 5 条指令的流水线图（如上图）
3. 思考：如果第 2 条指令依赖第 1 条的结果，会发生什么？

---

## 📚 推荐资料

- 《深入理解计算机系统（CSAPP）》第 4 章
- 《Computer Organization and Design》Chapter 4: Pipelining
- RISC-V 汇编语法参考资料
